#!/usr/bin/perl
use warnings;

my $regex_quote   = "[\"']";
my $regex_img     = '=' . $regex_quote . '([^"]*\.(jpe?g|png|gif))' . $regex_quote;
my $regex_href    = "<a [^>]*href$regex_img";
my $regex_imgsrc  = "<img [^>]*src$regex_img";
my $regex_both    = "<(a [^>]*href|img [^>]*src)$regex_img";

our $regex         = $regex_href;
our $dlcmd         = 'dlimage $$regex_subexpr while(s|$regex||i);';
our $regex_subexpr = 1;

our $currentpage   = undef;
our $wget_verbose  = 0;

our %downloads; # Map<PID, Link>
our %downloads_rev; # reverse of above, for lookup

our $threaded = 1;

sub usage()
{
	print <<EOD;
Usage: $0 [OPTIONS] [--] file(s)...

Where OPTIONS can be either:
  -i: Download images matching <img src="...">
  -a: Download images matching <a href="...">
  -b: Both -a and -a
  -v: Show wget output
  -T: Single 'threaded' (wait for each wget)

-a is default

Example usage:
\$ wget -qO - http://www.path.com/to/webpage.html | $0
\$ $0 -a path/to/local_webpage.html -i path/to/another.html
\$ $0 -b http://website.com/webpage.html local_file.html
EOD
	exit 1;
}

sub basename($)
{
	my $_ = $_[0];
	return $1 if m|.*/([^/]+)$|;
	return $_;
}

sub adddownload($)
{
	$link = $_[0];

	die "fork" unless defined($pid = fork());

	if($pid == 0){
		# child
		exec "wget " . ($wget_verbose ? '' : '-q') . " '$link'";
	}

	$downloads{$pid} = $link;
	$downloads_rev{$link} = $pid;
}

sub dlimage($)
{
	$file = basename($link = $_[0]);

	if(-e $file){
		print "have $link\n";
		return;
	}elsif(exists $downloads_rev{$link}){
		print "inprogress $link\n";
		return;
	}

	if($link =~ m|^/| || $link =~ m|^[^/]+$|){
		# append link name
		if($currentpage){
			if(substr($link, 0, 1) eq '/'){
				# non-relative
				($copy = $currentpage) =~ s#(http://[^/]+).*#$1#;
				$link = $copy . $link;
			}else{
				# relative - delete backwards until / is found
				($copy = $currentpage) =~ s#/[^/]+$##;
				$link = $copy . '/' . $link;
			}

			print STDERR "warning: appending links -> $link\n";
		}else{
			print "can't wget non-absolute link (no page ref): $link\n";
			return;
		}
	}

	# point of no return

	if($threaded){
		print "threaded, adddownload: $link\n" if $wget_verbose;
		adddownload $link;
	}else{
		$ret = system("wget " . ($wget_verbose ? '' : '-q') . " '$link'");
		if($ret != 0){
			if($ret == -1){
				print "couldn't start wget: $!\n";
			}else{
				print "$0: wget $link failed ($ret)\n";
			}
			exit 1;
		}
		print "wgot $link\n";
	}
}

sub linkmeupscotty
{
	if(defined($file = $_[0]) && !($file eq '-')){
		if(-e $file){
			open($fh,'<', $file) or die "$!\n";
			$currentpage = '';
		}else{
			open($fh, "wget -qO - $file |") or die "$!\n";
			$currentpage = $file;
		}

		eval $dlcmd while($_ = <$fh>);

		close $fh;
	}else{
		# no args - stdin
		eval $dlcmd while(<STDIN>);
	}
}

# local options
$doneone = 0;
$options = 1; # true while not found "--"

#$SIG{'CHLD'} = 'IGNORE' if $threaded;
# else this cocks up system()

for $arg(@ARGV){
	if($options && $arg eq '--help'){
		usage;

	}elsif($options && $arg eq '-v'){
		$wget_verbose = 1;
		next;

	}elsif($options && $arg eq '-i'){
		$regex_subexpr = 1;
		$regex = $regex_imgsrc;
		next;

	}elsif($options && $arg eq '-a'){
		$regex_subexpr = 1;
		$regex = $regex_href;
		next;

	}elsif($options && $arg eq '-b'){
		$regex_subexpr = 2;
		$regex = $regex_both;
		next;

	}elsif($options && $arg eq '-T'){
		$threaded = 0;
		next;

	}elsif($options && $arg eq '--'){
		$options = 0;
		next;

	}


	linkmeupscotty $arg;
	# stay in the loop:
	# options are relative to args
	$doneone = 1;
}

linkmeupscotty unless $doneone;

if($threaded){
	# collect downloads
	my %errs;

	while(keys %downloads){
		# status in $?
		$pid = wait();
		if($pid == -1){
			# should never get here
			print "wait() returned -1, still have children...?:\n";
			print "pid: $_, link: $downloads{$_}\n" for keys %downloads;
			exit 1;
		}

		print "wget = $? for " . $downloads{$pid} . "\n";
		$errs{$downloads{$pid}} = $? if $?;

		delete $downloads{$pid};
	}

	if(keys %errs){
		print STDERR "error $errs{$_} for $_\n" for keys %errs;
	}
}
