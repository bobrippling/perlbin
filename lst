#!/usr/bin/perl
use warnings;

use constant
{
	INDENT => "\t"
};

$argv0 = $0;
@exclude = ();
@include = ();


sub inset
{
	my $f = shift;
	return grep { $f =~ /$_/ } @_;
}

sub show($$)
{
	sub fileinfo($)
	{
		sub modestr($)
		{
			my $mode = shift;
			$mode %= 01000;
			sprintf '%o', $mode;
		}
		sub usrgrp($$)
		{
			my $uid = shift;
			my $gid = shift;
			my $name = getpwuid $uid;
			my $grp  = getgrgid $gid;
			return ($name ? $name : $uid) . ' ' . ($grp ? $grp : $gid);
		}
		sub date($)
		{
			use POSIX qw(strftime);
			return strftime "%a %d %H:%M", localtime;
		}
		sub size($)
		{
			my $n = shift;
			if($n > 1024){
				return sprintf '%.0dKB', $n / 1024;
			}
			return $n . "B";
		}

		my @stat = stat $_[0];

		return modestr($stat[2]) . ' ' .
			usrgrp($stat[4], $stat[5]) . ' ' .
		 	size($stat[7]) . ' ' .
			date($stat[9]);
	}

	my($path, $name) = @_;

	$name = $path if $opt{full};

	my %class = (
		'x' => ['*', \$col{green}   ],
		'd' => ['/', \$col{blue}    ],
		'l' => ['@', \$col{cyan}    ],
		'p' => ['|', \$col{purple}  ],
		'S' => ['=', \$col{brown}   ],
	);


	print INDENT x $indent;

	my $shown = 0;
	if($opt{classify}){
		for(keys %class){
			if(eval "-$_ '$path'"){
				print ${${$class{$_}}[1]},
							$name,
							$opt{classify} ? ${$class{$_}}[0] : '',
							"\e[m";

				$shown = 1;
				last;
			}
		}
	}

	print $name unless $shown;

	if($opt{long}){
		# -rw-r--r-- rob users 1143 $date
		print "\t\e[36m", fileinfo $path, "\e[m";
	}
	print "\n";
}

sub canshow
{
	my $f = shift;

	if(@include){
		return inset($f, @include) and not inset($f, @exclude);
	}else{
		return not inset($f, @exclude);
	}
}

sub lst
{
	for my $dir (@_){
		opendir(my $dh, $dir) or do{ warn "$argv0: opendir: $dir: $!\n"; next; };
		my @ents = readdir $dh;
		closedir $dh;

		for(@ents){
			next if $_ eq '.' or $_ eq '..';

			my $hidden = m#^\.#;
			my $file = "$dir/$_";

			if(canshow($file)){
				if(!$hidden or $opt{all}){
					show($file, $_);

					my $recurse = -d $file && $opt{recursive} && !($file =~ m#/\.\.?$#);

					if($recurse and -l $file){
						if($opt{follow_ln}){
							$recurse = 1;
						}else{
							$recurse = 0;
						}
					}

					if($recurse){
						$indent++;
						lst($file);
						$indent--;
					}
				}
			}
		}
	}
}

$indent  = 0;
$col     = -t STDOUT;

$argv0 = $1 if $argv0 =~ m#.*/([^/]+$)#;

my %ls_colours = map { split /=/ } split /:/, ($ENV{LS_COLORS} or '');
%col = (
	green   => "\e[" . ($ls_colours{ex} or "1;32") . 'm',
	blue    => "\e[" . ($ls_colours{di} or "0;34") . 'm',
	cyan    => "\e[" . ($ls_colours{ln} or "1;34") . 'm',
	purple  => "\e[" . ($ls_colours{pi} or "0;35") . 'm',
	brown   => "\e[" . ($ls_colours{so} or "0;33") . 'm',
);

%opt = (
	recursive => 1,
	full      => 0,
	all       => 0,
	classify  => 0,
	follow_ln => 0,
	long      => 0,
);

%args = (
	'-d' => [0, \$opt{recursive}],
	'-f' => [1, \$opt{full}     ],
	'-a' => [1, \$opt{all}      ],
	'-A' => [1, \$opt{all}      ], # for ls compat
	'-F' => [1, \$opt{classify} ],
	'-c' => [1, \$col           ],
	'-C' => [0, \$col           ],
	'-L' => [1, \$opt{follow_ln}],
	'-l' => [1, \$opt{long}     ],
);

while(@ARGV and $ARGV[0] =~ /^-/){
	if($ARGV[0] eq '--'){
		shift @ARGV;
		last;
	}elsif(my $ref = $args{$ARGV[0]}){
		${${$ref}[1]} = ${$ref}[0];

	}elsif($ARGV[0] =~ /^-(x)(.+)$/i){
		if($1 eq 'x'){
			push @exclude, $2;
		}else{
			push @include, $2;
		}

	}elsif($ARGV[0] eq '--help'){
		print "Usage: $0 [-a] [-R] [-f] [-xREGEX]...\n";
		print "  -a: All files\n";
		print "  -d: Don't recurse\n";
		print "  -f: Show full paths\n";
		print "  -F: Classify with */=>@|\n";
		print "  -L: Follow symbolic links\n";
		print "  -C: No colour (-c to force colour)\n";
		print "  -x: Exclude files matching REGEX\n";
		exit 1;
	}else{
		last;
	}

	shift @ARGV;
}

if(!$col){
	$col{$_} = '' for keys %col;
}

$ARGV[0] = '.' unless @ARGV;

lst @ARGV;
